/*
 The MySensors library adds a new layer on top of the RF24 library.
 It handles radio network routing, relaying and ids.

 Created by Henrik Ekblad <henrik.ekblad@gmail.com>
	
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.
*/

#ifndef MySensor_h
#define MySensor_h

#include "Version.h"   // Auto generated by bot
#include "MyConfig.h"
#include "MyMessage.h"
#include <nRF24L01.h>
#include <RF24.h>
#include <RF24_config.h>
#include <Arduino.h>
#include <stddef.h>
#include <SPI.h>
#include <EEPROM.h>
#include <avr/pgmspace.h>
#include <stdarg.h>

#ifdef DEBUG
#define debug(x,...) debugPrint(x, ##__VA_ARGS__)
#else
#define debug(x,...)
#endif

#define BAUD_RATE 115200

#define AUTO 0xFF // 0-254. Id 255 is reserved for auto initialization of radioId.
#define NODE_CHILD_ID 0xFF // Node child id is always created for when a new sensor is detected
#define EEPROM_RADIO_ID_ADDRESS 0 // Where to store radio id in EEPROM
#define EEPROM_RELAY_ID_ADDRESS 1 // Where to store relay id in EEPROM
#define EEPROM_DISTANCE_ADDRESS 2 // Where to store distance to gateway in EEPROM
#define EEPROM_ROUTES_ADDRESS ((uint8_t)3) // Where to start storing routing information in EEPROM. Will allocate 256 bytes.


// This is the radioId for sensor net gateway receiver sketch (where all sensors should send their data).
// This is also act as base value for sensor radioId
#define BASE_RADIO_ID ((uint64_t)0xA8A8E1FC00LL)
#define GATEWAY_ADDRESS ((uint8_t)0)
#define BROADCAST_ADDRESS ((uint8_t)0xFF)
#define TO_ADDR(x) (BASE_RADIO_ID + x)

#define WRITE_PIPE ((uint8_t)0)
#define CURRENT_NODE_PIPE ((uint8_t)1)
#define BROADCAST_PIPE ((uint8_t)2)

#define SEND_RETRIES 3
#define FIND_RELAY_RETRIES 2
#define FIND_RELAY_AFTER_FAILED_TRANSMISSIONS 20


class MySensor : public RF24
{
  public:
	/**
	* Constructor
	*
	* Creates a new instance of Sensor class.
	*
	* @param _cepin The pin attached to RF24 Chip Enable on the RF module (defualt 9)
	* @param _cspin The pin attached to RF24 Chip Select (default 10)
	*/
	MySensor(uint8_t _cepin=9, uint8_t _cspin=10);

	/**
	* Begin operation of the MySensors library
	*
	* Call this in setup(), before calling any other sensor net library methods.
	* @param incomingMessageCallback Callback function for incoming messages. Default is NULL
	* @param relayMode Activate relay mode. This node will forward messages to other nodes in the radio network. Make sure to call process() regularly. Default in false
	* @param radioId The unique id (1-254) for this sensor. Default is AUTO(255) which means sensor tries to fetch an id from controller.
	* @param paLevel Radio PA Level for this sensor. Default RF24_PA_MAX
	* @param channel Radio channel. Default is channel 76
	* @param dataRate Radio transmission speed. Default RF24_1MBPS
	*/

	void begin(void (* msgCallback)(MyMessage)=NULL, boolean relayMode=false, uint8_t radioId=AUTO, rf24_pa_dbm_e paLevel=RF24_PA_LEVEL, uint8_t channel=RF24_CHANNEL, rf24_datarate_e dataRate=RF24_DATARATE);

	/**
	 * Return the nodes radioId.
	 */
	uint8_t getRadioId();

	/**
	* Each node must present all attached sensors before any values can be handled correctly by the controller.
    * It is usually good to present all attached sensors after power-up in setup().
	*
	* @param sensorChildId Sensor child id for the presented. Choose anything between 0-254.
	* @param sensorType The sensor type. See sensor typedef in Message.h.
	*/
	void present(uint8_t sensorChildId, uint8_t sensorType);

	/**
	 * Sends sketch meta information to the gateway. Not mandatory but a nice thing to do.
	 * @param name String containing a short Sketch name or NULL  if not applicable
	 * @param version String containing a short Sketch version or NULL if not applicable
	 */
	void sketchInfo(const char *name, const char *version);

	/**
	* Sends a message to gateway or one of the other nodes in the radio network
	*
	* @param msg Message to send
	* @param ack Set this to true if you want destination node to send ack back to this node. Default is not to request any ack.
	* @param retry Number of attempts before giving up. Default is SEND_RETRIES
	* @return true Retuns false if ack is enabled and no ack came back
	*/
	bool send(MyMessage msg, bool ack=false, uint8_t retry=SEND_RETRIES);

	/**
	 * Send this nodes battery level to gateway.
	 * @param level Level between 0-100(%)
	 */
	void sendBatteryLevel(int level);

	/**
	* Fetches a value from gateway or some other sensor in the radio network. Resends request and waits for response.
	* Note that if you have registered a callback in begin() it will also be called before message is returned
	* by get()
	*
	* @param childSensorId  The unique child id for the different sensors connected to this arduino. 0-254.
	* @param variableType The variableType to fetch
	* @param destination The radioId of other node in radio network. Default is gateway
	* @param number of attempts to fetch
	* @return Message response
	*/
	MyMessage get(uint8_t childSensorId, uint8_t variableType, uint8_t destination=GATEWAY_ADDRESS, uint8_t retry=SEND_RETRIES);

	/**
	* Requests a value from gateway or some other sensor in the radio network.
	* Make sure to add callback in begin() to handle request response.
	*
	* @param childSensorId  The unique child id for the different sensors connected to this arduino. 0-254.
	* @param variableType The variableType to fetch
	* @param callback for result. This will be called when a message reply is received or request fails (see status of second argument).
	* @param destination The radioId of other node in radio network. Default is gateway
	*/
	/*void (* msgCallback)(MyMessage, bool)=NULL, */
	void request(uint8_t childSensorId, uint8_t variableType, uint8_t destination=GATEWAY_ADDRESS);


	/**
	 * Fetches time from sensor net gateway.
	 *
	 * @return Seconds since 1970, 0 if failed.
	 */
//	unsigned long getTime(uint8_t retry=SEND_RETRIES);
	void requestTime();

	/**
	 * Fetches unit setting from sensor net gateway. Returns true if metric system has been selected which means
	 * that sensor should report it's information in: celsius, meter, cm, gram, km/h, m/s etc..
	 * If false is returned the sensor should report data in imperial system which means
	 * fahrenheit, feet, gallon, mph etc...
	 */
	void requestIsMetricSystem();
//	bool isMetricSystem(uint8_t retry=SEND_RETRIES);


	/**
	 * Processes incoming messages to this node. If this is a relaying node it will
	* Returns true if there is a message addressed for this node just was received.
	* Use callback to handle incoming messages.
	*/
	boolean process(void);

	/**
	* Returns the last received message
	*/
	MyMessage getLastMessage(void);






#ifdef DEBUG
	void debugPrint(const char *fmt, ... );
	int freeRam();
#endif


  protected:
	MyMessage msg;  // Buffer for incoming messages.
	uint8_t failedTransmissions;
	boolean relayMode;
	uint8_t radioId;
	uint8_t distance; // This nodes distance to sensor net gateway (number of hops)
	uint8_t relayId;
	char convBuffer[20];

	void setupRelayMode();
	void setupRadio(rf24_pa_dbm_e paLevel, uint8_t channel, rf24_datarate_e dataRate);
	void findRelay();
	boolean sendRoute(MyMessage message);
	boolean sendWrite(uint8_t dest, MyMessage message);
	void sendInternal(uint8_t variableType, const char *value);
	boolean sendAck(MyMessage message);
	boolean sendData(uint8_t from, uint8_t to, uint8_t childId, uint8_t messageType, uint8_t type, const char *data, uint8_t length, boolean binaryMessage);
	uint8_t validate(MyMessage message);
	void sendChildren();


  private:
	// Callbacks for reqeusts
/*	struct callback {
		bool active; // Deactivates callback after each reply
		uint8_t command; // Command type
		uint8_t sender;
		uint8_t sensor;
		uint8_t type;
		void (*msgCallback)(MyMessage, bool);
	};*/
	MyMessage ack;  // Buffer for ack messages.
	uint8_t *childNodeTable; // In memory buffer for routing to other nodes. Also stored in EEPROM
    void (*msgCallback)(MyMessage); // Callback for undefined incoming messages

	void initializeRadioId();
	uint8_t crc8Message(MyMessage);
	MyMessage wait(MyMessage msg, uint8_t expectedReceiveType, uint8_t retry);
	MyMessage getInternal(uint8_t variableType, uint8_t retry=SEND_RETRIES);

	uint8_t getChildRoute(uint8_t childId);
	void addChildRoute(uint8_t childId, uint8_t route);
	void removeChildRoute(uint8_t childId);
	void clearChildRoutes();
};

#endif
